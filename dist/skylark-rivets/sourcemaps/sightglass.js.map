{"version":3,"sources":["sightglass.js"],"names":["define","Rivets","sightglass","obj","keypath","callback","options","Observer","this","adapters","objectPath","update","bind","parse","isObject","target","realize","set","key","error","message","Error","tokenize","interfaces","root","index","chr","tokens","current","i","path","length","charAt","indexOf","push","prototype","substr","pop","prev","unreached","forEach","token","get","splice","next","oldValue","value","Function","setValue","adapter","active","action","Object","keys","unobserve"],"mappings":";;;;;;;AAAAA,QAAQ,YAAY,SAASC,GAG3B,SAASC,EAAWC,EAAKC,EAASC,EAAUC,GAC1C,OAAO,IAAIC,EAASJ,EAAKC,EAASC,EAAUC,GAO9C,SAASC,EAASJ,EAAKC,EAASC,EAAUC,GACxCE,KAAKF,QAAUA,MACfE,KAAKF,QAAQG,SAAWD,KAAKF,QAAQG,aACrCD,KAAKL,IAAMA,EACXK,KAAKJ,QAAUA,EACfI,KAAKH,SAAWA,EAChBG,KAAKE,cACLF,KAAKG,OAASH,KAAKG,OAAOC,KAAKJ,MAC/BA,KAAKK,QAEDC,EAASN,KAAKO,OAASP,KAAKQ,YAC9BR,KAAKS,KAAI,EAAMT,KAAKU,IAAKV,KAAKO,OAAQP,KAAKH,UA6K/C,SAASS,EAASX,GAChB,MAAsB,iBAARA,GAA4B,OAARA,EAIpC,SAASgB,EAAMC,GACb,MAAM,IAAIC,MAAM,gBAAkBD,GAGpC,OApMAlB,EAAWO,YAoBXF,EAASe,SAAW,SAASlB,EAASmB,EAAYC,GAChD,IAEIC,EAAOC,EAFPC,KACAC,GAAWC,EAAGL,EAAMM,KAAM,IAG9B,IAAKL,EAAQ,EAAGA,EAAQrB,EAAQ2B,OAAQN,IACtCC,EAAMtB,EAAQ4B,OAAOP,IAEdF,EAAWU,QAAQP,IACxBC,EAAOO,KAAKN,GACZA,GAAWC,EAAGH,EAAKI,KAAM,KAEzBF,EAAQE,MAAQJ,EAKpB,OADAC,EAAOO,KAAKN,GACLD,GAKTpB,EAAS4B,UAAUtB,MAAQ,WACzB,IACIW,EAAMM,EADNP,EAAaf,KAAKe,aAGjBA,EAAWQ,QACdZ,EAAM,gDAGDI,EAAWU,QAAQzB,KAAKJ,QAAQ,KACrCoB,EAAOhB,KAAKJ,QAAQ,GACpB0B,EAAOtB,KAAKJ,QAAQgC,OAAO,UAEkC,KAAjDZ,EAAOhB,KAAKF,QAAQkB,MAAQtB,EAAWsB,OACjDL,EAAM,uCAGRW,EAAOtB,KAAKJ,SAGdI,KAAKmB,OAASpB,EAASe,SAASQ,EAAMP,EAAYC,GAClDhB,KAAKU,IAAMV,KAAKmB,OAAOU,OAKzB9B,EAAS4B,UAAUnB,QAAU,WAC3B,IAEIsB,EAFAV,EAAUpB,KAAKL,IACfoC,GAAY,EAgChB,OA7BA/B,KAAKmB,OAAOa,QAAQ,SAASC,EAAOhB,GAC9BX,EAASc,SAC2B,IAA3BpB,KAAKE,WAAWe,GACrBG,KAAaU,EAAO9B,KAAKE,WAAWe,MACtCjB,KAAKS,KAAI,EAAOwB,EAAOH,EAAM9B,KAAKG,QAClCH,KAAKS,KAAI,EAAMwB,EAAOb,EAASpB,KAAKG,QACpCH,KAAKE,WAAWe,GAASG,IAG3BpB,KAAKS,KAAI,EAAMwB,EAAOb,EAASpB,KAAKG,QACpCH,KAAKE,WAAWe,GAASG,GAG3BA,EAAUpB,KAAKkC,IAAID,EAAOb,MAER,IAAdW,IACFA,EAAYd,IAGVa,EAAO9B,KAAKE,WAAWe,KACzBjB,KAAKS,KAAI,EAAOwB,EAAOH,EAAM9B,KAAKG,UAGrCH,OAEe,IAAd+B,GACF/B,KAAKE,WAAWiC,OAAOJ,GAGlBX,GAITrB,EAAS4B,UAAUxB,OAAS,WAC1B,IAAIiC,EAAMC,GAELD,EAAOpC,KAAKQ,aAAeR,KAAKO,SAC/BD,EAASN,KAAKO,SAChBP,KAAKS,KAAI,EAAOT,KAAKU,IAAKV,KAAKO,OAAQP,KAAKH,UAG1CS,EAAS8B,IACXpC,KAAKS,KAAI,EAAMT,KAAKU,IAAK0B,EAAMpC,KAAKH,UAGtCwC,EAAWrC,KAAKsC,QAChBtC,KAAKO,OAAS6B,GAGVpC,KAAKsC,kBAAmBC,UAAYvC,KAAKsC,UAAYD,IAAUrC,KAAKH,aAM5EE,EAAS4B,UAAUW,MAAQ,WACzB,GAAIhC,EAASN,KAAKO,QAChB,OAAOP,KAAKkC,IAAIlC,KAAKU,IAAKV,KAAKO,SAMnCR,EAAS4B,UAAUa,SAAW,SAASF,GACjChC,EAASN,KAAKO,SAChBP,KAAKyC,QAAQzC,KAAKU,KAAKD,IAAIT,KAAKO,OAAQP,KAAKU,IAAIY,KAAMgB,IAK3DvC,EAAS4B,UAAUO,IAAM,SAASxB,EAAKf,GACrC,OAAOK,KAAKyC,QAAQ/B,GAAKwB,IAAIvC,EAAKe,EAAIY,OAIxCvB,EAAS4B,UAAUlB,IAAM,SAASiC,EAAQhC,EAAKf,EAAKE,GAClD,IAAI8C,EAASD,EAAS,UAAY,YAClC1C,KAAKyC,QAAQ/B,GAAKiC,GAAQhD,EAAKe,EAAIY,KAAMzB,IAI3CE,EAAS4B,UAAUZ,WAAa,WAC9B,IAAIA,EAAa6B,OAAOC,KAAK7C,KAAKF,QAAQG,UAQ1C,OANA2C,OAAOC,KAAKnD,EAAWO,UAAU+B,QAAQ,SAASX,IAC1CN,EAAWU,QAAQJ,IACvBN,EAAWW,KAAKL,KAIbN,GAIThB,EAAS4B,UAAUc,QAAU,SAAS/B,GACpC,OAAOV,KAAKF,QAAQG,SAASS,EAAIW,IAC/B3B,EAAWO,SAASS,EAAIW,IAI5BtB,EAAS4B,UAAUmB,UAAY,WAC7B,IAAInD,EAEJK,KAAKmB,OAAOa,QAAQ,SAASC,EAAOhB,IAC9BtB,EAAMK,KAAKE,WAAWe,KACxBjB,KAAKS,KAAI,EAAOwB,EAAOtC,EAAKK,KAAKG,SAElCH,MAECM,EAASN,KAAKO,SAChBP,KAAKS,KAAI,EAAOT,KAAKU,IAAKV,KAAKO,OAAQP,KAAKH,WAczCJ,EAAOC,WAAcA","file":"../sightglass.js","sourcesContent":["define([\"./rivets\"],function(Rivets){\r\n\r\n  // Public sightglass interface.\r\n  function sightglass(obj, keypath, callback, options) {\r\n    return new Observer(obj, keypath, callback, options)\r\n  }\r\n\r\n  // Batteries not included.\r\n  sightglass.adapters = {}\r\n\r\n  // Constructs a new keypath observer and kicks things off.\r\n  function Observer(obj, keypath, callback, options) {\r\n    this.options = options || {}\r\n    this.options.adapters = this.options.adapters || {}\r\n    this.obj = obj\r\n    this.keypath = keypath\r\n    this.callback = callback\r\n    this.objectPath = []\r\n    this.update = this.update.bind(this)\r\n    this.parse()\r\n\r\n    if (isObject(this.target = this.realize())) {\r\n      this.set(true, this.key, this.target, this.callback)\r\n    }\r\n  }\r\n\r\n  // Tokenizes the provided keypath string into interface + path tokens for the\r\n  // observer to work with.\r\n  Observer.tokenize = function(keypath, interfaces, root) {\r\n    var tokens = []\r\n    var current = {i: root, path: ''}\r\n    var index, chr\r\n\r\n    for (index = 0; index < keypath.length; index++) {\r\n      chr = keypath.charAt(index)\r\n\r\n      if (!!~interfaces.indexOf(chr)) {\r\n        tokens.push(current)\r\n        current = {i: chr, path: ''}\r\n      } else {\r\n        current.path += chr\r\n      }\r\n    }\r\n\r\n    tokens.push(current)\r\n    return tokens\r\n  }\r\n\r\n  // Parses the keypath using the interfaces defined on the view. Sets variables\r\n  // for the tokenized keypath as well as the end key.\r\n  Observer.prototype.parse = function() {\r\n    var interfaces = this.interfaces()\r\n    var root, path\r\n\r\n    if (!interfaces.length) {\r\n      error('Must define at least one adapter interface.')\r\n    }\r\n\r\n    if (!!~interfaces.indexOf(this.keypath[0])) {\r\n      root = this.keypath[0]\r\n      path = this.keypath.substr(1)\r\n    } else {\r\n      if (typeof (root = this.options.root || sightglass.root) === 'undefined') {\r\n        error('Must define a default root adapter.')\r\n      }\r\n\r\n      path = this.keypath\r\n    }\r\n\r\n    this.tokens = Observer.tokenize(path, interfaces, root)\r\n    this.key = this.tokens.pop()\r\n  }\r\n\r\n  // Realizes the full keypath, attaching observers for every key and correcting\r\n  // old observers to any changed objects in the keypath.\r\n  Observer.prototype.realize = function() {\r\n    var current = this.obj\r\n    var unreached = false\r\n    var prev\r\n\r\n    this.tokens.forEach(function(token, index) {\r\n      if (isObject(current)) {\r\n        if (typeof this.objectPath[index] !== 'undefined') {\r\n          if (current !== (prev = this.objectPath[index])) {\r\n            this.set(false, token, prev, this.update)\r\n            this.set(true, token, current, this.update)\r\n            this.objectPath[index] = current\r\n          }\r\n        } else {\r\n          this.set(true, token, current, this.update)\r\n          this.objectPath[index] = current\r\n        }\r\n\r\n        current = this.get(token, current)\r\n      } else {\r\n        if (unreached === false) {\r\n          unreached = index\r\n        }\r\n\r\n        if (prev = this.objectPath[index]) {\r\n          this.set(false, token, prev, this.update)\r\n        }\r\n      }\r\n    }, this)\r\n\r\n    if (unreached !== false) {\r\n      this.objectPath.splice(unreached)\r\n    }\r\n\r\n    return current\r\n  }\r\n\r\n  // Updates the keypath. This is called when any intermediary key is changed.\r\n  Observer.prototype.update = function() {\r\n    var next, oldValue\r\n\r\n    if ((next = this.realize()) !== this.target) {\r\n      if (isObject(this.target)) {\r\n        this.set(false, this.key, this.target, this.callback)\r\n      }\r\n\r\n      if (isObject(next)) {\r\n        this.set(true, this.key, next, this.callback)\r\n      }\r\n\r\n      oldValue = this.value()\r\n      this.target = next\r\n\r\n      // Always call callback if value is a function. If not a function, call callback only if value changed\r\n      if (this.value() instanceof Function || this.value() !== oldValue) this.callback()\r\n    }\r\n  }\r\n\r\n  // Reads the current end value of the observed keypath. Returns undefined if\r\n  // the full keypath is unreachable.\r\n  Observer.prototype.value = function() {\r\n    if (isObject(this.target)) {\r\n      return this.get(this.key, this.target)\r\n    }\r\n  }\r\n\r\n  // Sets the current end value of the observed keypath. Calling setValue when\r\n  // the full keypath is unreachable is a no-op.\r\n  Observer.prototype.setValue = function(value) {\r\n    if (isObject(this.target)) {\r\n      this.adapter(this.key).set(this.target, this.key.path, value)\r\n    }\r\n  }\r\n\r\n  // Gets the provided key on an object.\r\n  Observer.prototype.get = function(key, obj) {\r\n    return this.adapter(key).get(obj, key.path)\r\n  }\r\n\r\n  // Observes or unobserves a callback on the object using the provided key.\r\n  Observer.prototype.set = function(active, key, obj, callback) {\r\n    var action = active ? 'observe' : 'unobserve'\r\n    this.adapter(key)[action](obj, key.path, callback)\r\n  }\r\n\r\n  // Returns an array of all unique adapter interfaces available.\r\n  Observer.prototype.interfaces = function() {\r\n    var interfaces = Object.keys(this.options.adapters)\r\n\r\n    Object.keys(sightglass.adapters).forEach(function(i) {\r\n      if (!~interfaces.indexOf(i)) {\r\n        interfaces.push(i)\r\n      }\r\n    })\r\n\r\n    return interfaces\r\n  }\r\n\r\n  // Convenience function to grab the adapter for a specific key.\r\n  Observer.prototype.adapter = function(key) {\r\n    return this.options.adapters[key.i] ||\r\n      sightglass.adapters[key.i]\r\n  }\r\n\r\n  // Unobserves the entire keypath.\r\n  Observer.prototype.unobserve = function() {\r\n    var obj\r\n\r\n    this.tokens.forEach(function(token, index) {\r\n      if (obj = this.objectPath[index]) {\r\n        this.set(false, token, obj, this.update)\r\n      }\r\n    }, this)\r\n\r\n    if (isObject(this.target)) {\r\n      this.set(false, this.key, this.target, this.callback)\r\n    }\r\n  }\r\n\r\n  // Check if a value is an object than can be observed.\r\n  function isObject(obj) {\r\n    return typeof obj === 'object' && obj !== null\r\n  }\r\n\r\n  // Error thrower.\r\n  function error(message) {\r\n    throw new Error('[sightglass] ' + message)\r\n  }\r\n\r\n  return Rivets.sightglass =  sightglass;\r\n});\r\n\r\n"]}