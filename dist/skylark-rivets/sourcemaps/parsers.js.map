{"version":3,"sources":["parsers.js"],"names":["define","Rivets","TypeParser","types","primitive","keypath","parse","string","test","type","this","value","slice","isNaN","Number","TextTemplateParser","text","binding","template","delimiters","index","lastIndex","lastToken","length","substring","tokens","indexOf","push","trim"],"mappings":";;;;;;;AAAAA,QAAQ,YAAY,SAASC,GAsH3B,OApHAA,EAAOC,WAAa,WAClB,SAASA,KAmDT,OAjDAA,EAAWC,OACTC,UAAW,EACXC,QAAS,GAGXH,EAAWI,MAAQ,SAASC,GAC1B,MAAI,gBAAgBC,KAAKD,IAErBE,KAAMC,KAAKP,MAAMC,UACjBO,MAAOJ,EAAOK,MAAM,GAAI,IAEN,SAAXL,GAEPE,KAAMC,KAAKP,MAAMC,UACjBO,OAAO,GAEW,UAAXJ,GAEPE,KAAMC,KAAKP,MAAMC,UACjBO,OAAO,GAEW,SAAXJ,GAEPE,KAAMC,KAAKP,MAAMC,UACjBO,MAAO,MAEW,cAAXJ,GAEPE,KAAMC,KAAKP,MAAMC,UACjBO,WAAO,GAEW,KAAXJ,GAEPE,KAAMC,KAAKP,MAAMC,UACjBO,WAAO,IAE0B,IAA1BE,MAAMC,OAAOP,KAEpBE,KAAMC,KAAKP,MAAMC,UACjBO,MAAOG,OAAOP,KAIdE,KAAMC,KAAKP,MAAME,QACjBM,MAAOJ,IAKNL,EApDW,GAwDpBD,EAAOc,mBAAqB,WAC1B,SAASA,KAsDT,OApDAA,EAAmBZ,OACjBa,KAAM,EACNC,QAAS,GAGXF,EAAmBT,MAAQ,SAASY,EAAUC,GAC5C,IAAIC,EAAOC,EAAWC,EAAWC,EAAQC,EAAWC,EAAQd,EAK5D,IAJAc,KACAF,EAASL,EAASK,OAClBH,EAAQ,EACRC,EAAY,EACLA,EAAYE,GAAQ,CAEzB,IADAH,EAAQF,EAASQ,QAAQP,EAAW,GAAIE,IAC5B,EAAG,CACbI,EAAOE,MACLlB,KAAMC,KAAKP,MAAMa,KACjBL,MAAOO,EAASN,MAAMS,KAExB,MAUA,GARID,EAAQ,GAAKC,EAAYD,GAC3BK,EAAOE,MACLlB,KAAMC,KAAKP,MAAMa,KACjBL,MAAOO,EAASN,MAAMS,EAAWD,KAGrCC,EAAYD,EAAQD,EAAW,GAAGI,QAClCH,EAAQF,EAASQ,QAAQP,EAAW,GAAIE,IAC5B,EAAG,CACbG,EAAYN,EAASN,MAAMS,EAAYF,EAAW,GAAGI,SAEnC,OADlBD,EAAYG,EAAOA,EAAOF,OAAS,IACVD,EAAUb,UAAO,KAAYC,KAAKP,MAAMa,KAC/DM,EAAUX,OAASa,EAEnBC,EAAOE,MACLlB,KAAMC,KAAKP,MAAMa,KACjBL,MAAOa,IAGX,MAEFb,EAAQO,EAASN,MAAMS,EAAWD,GAAOQ,OACzCH,EAAOE,MACLlB,KAAMC,KAAKP,MAAMc,QACjBN,MAAOA,IAETU,EAAYD,EAAQD,EAAW,GAAGI,OAGtC,OAAOE,GAGFV,EAvDmB,IA6D1Bb,WAAaD,EAAOC,WACpBa,mBAAqBd,EAAOc","file":"../parsers.js","sourcesContent":["define([\"./rivets\"],function(Rivets){\r\n\r\n  Rivets.TypeParser = (function() {\r\n    function TypeParser() {}\r\n\r\n    TypeParser.types = {\r\n      primitive: 0,\r\n      keypath: 1\r\n    };\r\n\r\n    TypeParser.parse = function(string) {\r\n      if (/^'.*'$|^\".*\"$/.test(string)) {\r\n        return {\r\n          type: this.types.primitive,\r\n          value: string.slice(1, -1)\r\n        };\r\n      } else if (string === 'true') {\r\n        return {\r\n          type: this.types.primitive,\r\n          value: true\r\n        };\r\n      } else if (string === 'false') {\r\n        return {\r\n          type: this.types.primitive,\r\n          value: false\r\n        };\r\n      } else if (string === 'null') {\r\n        return {\r\n          type: this.types.primitive,\r\n          value: null\r\n        };\r\n      } else if (string === 'undefined') {\r\n        return {\r\n          type: this.types.primitive,\r\n          value: void 0\r\n        };\r\n      } else if (string === '') {\r\n        return {\r\n          type: this.types.primitive,\r\n          value: void 0\r\n        };\r\n      } else if (isNaN(Number(string)) === false) {\r\n        return {\r\n          type: this.types.primitive,\r\n          value: Number(string)\r\n        };\r\n      } else {\r\n        return {\r\n          type: this.types.keypath,\r\n          value: string\r\n        };\r\n      }\r\n    };\r\n\r\n    return TypeParser;\r\n\r\n  })();\r\n\r\n  Rivets.TextTemplateParser = (function() {\r\n    function TextTemplateParser() {}\r\n\r\n    TextTemplateParser.types = {\r\n      text: 0,\r\n      binding: 1\r\n    };\r\n\r\n    TextTemplateParser.parse = function(template, delimiters) {\r\n      var index, lastIndex, lastToken, length, substring, tokens, value;\r\n      tokens = [];\r\n      length = template.length;\r\n      index = 0;\r\n      lastIndex = 0;\r\n      while (lastIndex < length) {\r\n        index = template.indexOf(delimiters[0], lastIndex);\r\n        if (index < 0) {\r\n          tokens.push({\r\n            type: this.types.text,\r\n            value: template.slice(lastIndex)\r\n          });\r\n          break;\r\n        } else {\r\n          if (index > 0 && lastIndex < index) {\r\n            tokens.push({\r\n              type: this.types.text,\r\n              value: template.slice(lastIndex, index)\r\n            });\r\n          }\r\n          lastIndex = index + delimiters[0].length;\r\n          index = template.indexOf(delimiters[1], lastIndex);\r\n          if (index < 0) {\r\n            substring = template.slice(lastIndex - delimiters[1].length);\r\n            lastToken = tokens[tokens.length - 1];\r\n            if ((lastToken != null ? lastToken.type : void 0) === this.types.text) {\r\n              lastToken.value += substring;\r\n            } else {\r\n              tokens.push({\r\n                type: this.types.text,\r\n                value: substring\r\n              });\r\n            }\r\n            break;\r\n          }\r\n          value = template.slice(lastIndex, index).trim();\r\n          tokens.push({\r\n            type: this.types.binding,\r\n            value: value\r\n          });\r\n          lastIndex = index + delimiters[1].length;\r\n        }\r\n      }\r\n      return tokens;\r\n    };\r\n\r\n    return TextTemplateParser;\r\n\r\n  })();\r\n\r\n\r\n  return {\r\n    TypeParser : Rivets.TypeParser,\r\n    TextTemplateParser : Rivets.TextTemplateParser\r\n  };\r\n\r\n});\r\n\r\n"]}