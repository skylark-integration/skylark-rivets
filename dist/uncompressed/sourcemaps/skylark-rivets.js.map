{"version":3,"sources":["skylark-rivets.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"../skylark-rivets.js","sourcesContent":["define('skylark-rivets/rivets',[\n  \"skylark-langx/skylark\",\n  \"./sightglass\"\n],function(skylark,sightglass) {\n// Rivets.js\n// version: 0.9.6\n// author: Michael Richards\n// license: MIT\n  var  Rivets = {\n    options: ['prefix', 'templateDelimiters', 'rootInterface', 'preloadData', 'handler', 'executeFunctions'],\n    extensions: [],\n    extensions: ['binders', 'formatters', 'components', 'adapters'],\n    \"public\": {\n      binders: {},\n      components: {},\n      formatters: {},\n      adapters: {},\n      prefix: 'rv',\n      templateDelimiters: ['{', '}'],\n      rootInterface: '.',\n      preloadData: true,\n      executeFunctions: false,\n      iterationAlias: function(modelName) {\n        return '%' + modelName + '%';\n      },\n      handler: function(context, ev, binding) {\n        return this.call(context, ev, binding.view.models);\n      },\n      configure: function(options) {\n        var descriptor, key, option, value;\n        if (options == null) {\n          options = {};\n        }\n        for (option in options) {\n          value = options[option];\n          if (option === 'binders' || option === 'components' || option === 'formatters' || option === 'adapters') {\n            for (key in value) {\n              descriptor = value[key];\n              Rivets[option][key] = descriptor;\n            }\n          } else {\n            Rivets[\"public\"][option] = value;\n          }\n        }\n      },\n      bind: function(el, models, options) {\n        var view;\n        if (models == null) {\n          models = {};\n        }\n        if (options == null) {\n          options = {};\n        }\n        view = new Rivets.View(el, models, options);\n        view.bind();\n        return view;\n      },\n      init: function(component, el, data) {\n        var scope, template, view;\n        if (data == null) {\n          data = {};\n        }\n        if (el == null) {\n          el = document.createElement('div');\n        }\n        component = Rivets[\"public\"].components[component];\n        template = component.template.call(this, el);\n        if (template instanceof HTMLElement) {\n          while (el.firstChild) {\n            el.removeChild(el.firstChild);\n          }\n          el.appendChild(template);\n        } else {\n          el.innerHTML = template;\n        }\n        scope = component.initialize.call(this, el, data);\n        view = new Rivets.View(el, scope);\n        view.bind();\n        return view;\n      }\n    }\n  };\n\n  return skylark.rivets = Rivets;\n\n});\n\ndefine('skylark-rivets/sightglass',[\"./rivets\"],function(Rivets){\r\n\r\n  // Public sightglass interface.\r\n  function sightglass(obj, keypath, callback, options) {\r\n    return new Observer(obj, keypath, callback, options)\r\n  }\r\n\r\n  // Batteries not included.\r\n  sightglass.adapters = {}\r\n\r\n  // Constructs a new keypath observer and kicks things off.\r\n  function Observer(obj, keypath, callback, options) {\r\n    this.options = options || {}\r\n    this.options.adapters = this.options.adapters || {}\r\n    this.obj = obj\r\n    this.keypath = keypath\r\n    this.callback = callback\r\n    this.objectPath = []\r\n    this.update = this.update.bind(this)\r\n    this.parse()\r\n\r\n    if (isObject(this.target = this.realize())) {\r\n      this.set(true, this.key, this.target, this.callback)\r\n    }\r\n  }\r\n\r\n  // Tokenizes the provided keypath string into interface + path tokens for the\r\n  // observer to work with.\r\n  Observer.tokenize = function(keypath, interfaces, root) {\r\n    var tokens = []\r\n    var current = {i: root, path: ''}\r\n    var index, chr\r\n\r\n    for (index = 0; index < keypath.length; index++) {\r\n      chr = keypath.charAt(index)\r\n\r\n      if (!!~interfaces.indexOf(chr)) {\r\n        tokens.push(current)\r\n        current = {i: chr, path: ''}\r\n      } else {\r\n        current.path += chr\r\n      }\r\n    }\r\n\r\n    tokens.push(current)\r\n    return tokens\r\n  }\r\n\r\n  // Parses the keypath using the interfaces defined on the view. Sets variables\r\n  // for the tokenized keypath as well as the end key.\r\n  Observer.prototype.parse = function() {\r\n    var interfaces = this.interfaces()\r\n    var root, path\r\n\r\n    if (!interfaces.length) {\r\n      error('Must define at least one adapter interface.')\r\n    }\r\n\r\n    if (!!~interfaces.indexOf(this.keypath[0])) {\r\n      root = this.keypath[0]\r\n      path = this.keypath.substr(1)\r\n    } else {\r\n      if (typeof (root = this.options.root || sightglass.root) === 'undefined') {\r\n        error('Must define a default root adapter.')\r\n      }\r\n\r\n      path = this.keypath\r\n    }\r\n\r\n    this.tokens = Observer.tokenize(path, interfaces, root)\r\n    this.key = this.tokens.pop()\r\n  }\r\n\r\n  // Realizes the full keypath, attaching observers for every key and correcting\r\n  // old observers to any changed objects in the keypath.\r\n  Observer.prototype.realize = function() {\r\n    var current = this.obj\r\n    var unreached = false\r\n    var prev\r\n\r\n    this.tokens.forEach(function(token, index) {\r\n      if (isObject(current)) {\r\n        if (typeof this.objectPath[index] !== 'undefined') {\r\n          if (current !== (prev = this.objectPath[index])) {\r\n            this.set(false, token, prev, this.update)\r\n            this.set(true, token, current, this.update)\r\n            this.objectPath[index] = current\r\n          }\r\n        } else {\r\n          this.set(true, token, current, this.update)\r\n          this.objectPath[index] = current\r\n        }\r\n\r\n        current = this.get(token, current)\r\n      } else {\r\n        if (unreached === false) {\r\n          unreached = index\r\n        }\r\n\r\n        if (prev = this.objectPath[index]) {\r\n          this.set(false, token, prev, this.update)\r\n        }\r\n      }\r\n    }, this)\r\n\r\n    if (unreached !== false) {\r\n      this.objectPath.splice(unreached)\r\n    }\r\n\r\n    return current\r\n  }\r\n\r\n  // Updates the keypath. This is called when any intermediary key is changed.\r\n  Observer.prototype.update = function() {\r\n    var next, oldValue\r\n\r\n    if ((next = this.realize()) !== this.target) {\r\n      if (isObject(this.target)) {\r\n        this.set(false, this.key, this.target, this.callback)\r\n      }\r\n\r\n      if (isObject(next)) {\r\n        this.set(true, this.key, next, this.callback)\r\n      }\r\n\r\n      oldValue = this.value()\r\n      this.target = next\r\n\r\n      // Always call callback if value is a function. If not a function, call callback only if value changed\r\n      if (this.value() instanceof Function || this.value() !== oldValue) this.callback()\r\n    }\r\n  }\r\n\r\n  // Reads the current end value of the observed keypath. Returns undefined if\r\n  // the full keypath is unreachable.\r\n  Observer.prototype.value = function() {\r\n    if (isObject(this.target)) {\r\n      return this.get(this.key, this.target)\r\n    }\r\n  }\r\n\r\n  // Sets the current end value of the observed keypath. Calling setValue when\r\n  // the full keypath is unreachable is a no-op.\r\n  Observer.prototype.setValue = function(value) {\r\n    if (isObject(this.target)) {\r\n      this.adapter(this.key).set(this.target, this.key.path, value)\r\n    }\r\n  }\r\n\r\n  // Gets the provided key on an object.\r\n  Observer.prototype.get = function(key, obj) {\r\n    return this.adapter(key).get(obj, key.path)\r\n  }\r\n\r\n  // Observes or unobserves a callback on the object using the provided key.\r\n  Observer.prototype.set = function(active, key, obj, callback) {\r\n    var action = active ? 'observe' : 'unobserve'\r\n    this.adapter(key)[action](obj, key.path, callback)\r\n  }\r\n\r\n  // Returns an array of all unique adapter interfaces available.\r\n  Observer.prototype.interfaces = function() {\r\n    var interfaces = Object.keys(this.options.adapters)\r\n\r\n    Object.keys(sightglass.adapters).forEach(function(i) {\r\n      if (!~interfaces.indexOf(i)) {\r\n        interfaces.push(i)\r\n      }\r\n    })\r\n\r\n    return interfaces\r\n  }\r\n\r\n  // Convenience function to grab the adapter for a specific key.\r\n  Observer.prototype.adapter = function(key) {\r\n    return this.options.adapters[key.i] ||\r\n      sightglass.adapters[key.i]\r\n  }\r\n\r\n  // Unobserves the entire keypath.\r\n  Observer.prototype.unobserve = function() {\r\n    var obj\r\n\r\n    this.tokens.forEach(function(token, index) {\r\n      if (obj = this.objectPath[index]) {\r\n        this.set(false, token, obj, this.update)\r\n      }\r\n    }, this)\r\n\r\n    if (isObject(this.target)) {\r\n      this.set(false, this.key, this.target, this.callback)\r\n    }\r\n  }\r\n\r\n  // Check if a value is an object than can be observed.\r\n  function isObject(obj) {\r\n    return typeof obj === 'object' && obj !== null\r\n  }\r\n\r\n  // Error thrower.\r\n  function error(message) {\r\n    throw new Error('[sightglass] ' + message)\r\n  }\r\n\r\n  return Rivets.sightglass =  sightglass;\r\n});\r\n\r\n\ndefine('skylark-rivets/adapter',[\"./rivets\"],function(Rivets){\r\n  var __indexOf = [].indexOf;\r\n\r\n  Rivets[\"public\"].adapters['.'] = {\r\n    id: '_rv',\r\n    counter: 0,\r\n    weakmap: {},\r\n    weakReference: function(obj) {\r\n      var id, _base, _name;\r\n      if (!obj.hasOwnProperty(this.id)) {\r\n        id = this.counter++;\r\n        Object.defineProperty(obj, this.id, {\r\n          value: id\r\n        });\r\n      }\r\n      return (_base = this.weakmap)[_name = obj[this.id]] || (_base[_name] = {\r\n        callbacks: {}\r\n      });\r\n    },\r\n    cleanupWeakReference: function(ref, id) {\r\n      if (!Object.keys(ref.callbacks).length) {\r\n        if (!(ref.pointers && Object.keys(ref.pointers).length)) {\r\n          return delete this.weakmap[id];\r\n        }\r\n      }\r\n    },\r\n    stubFunction: function(obj, fn) {\r\n      var map, original, weakmap;\r\n      original = obj[fn];\r\n      map = this.weakReference(obj);\r\n      weakmap = this.weakmap;\r\n      return obj[fn] = function() {\r\n        var callback, k, r, response, _i, _len, _ref1, _ref2, _ref3, _ref4;\r\n        response = original.apply(obj, arguments);\r\n        _ref1 = map.pointers;\r\n        for (r in _ref1) {\r\n          k = _ref1[r];\r\n          _ref4 = (_ref2 = (_ref3 = weakmap[r]) != null ? _ref3.callbacks[k] : void 0) != null ? _ref2 : [];\r\n          for (_i = 0, _len = _ref4.length; _i < _len; _i++) {\r\n            callback = _ref4[_i];\r\n            callback();\r\n          }\r\n        }\r\n        return response;\r\n      };\r\n    },\r\n    observeMutations: function(obj, ref, keypath) {\r\n      var fn, functions, map, _base, _i, _len;\r\n      if (Array.isArray(obj)) {\r\n        map = this.weakReference(obj);\r\n        if (map.pointers == null) {\r\n          map.pointers = {};\r\n          functions = ['push', 'pop', 'shift', 'unshift', 'sort', 'reverse', 'splice'];\r\n          for (_i = 0, _len = functions.length; _i < _len; _i++) {\r\n            fn = functions[_i];\r\n            this.stubFunction(obj, fn);\r\n          }\r\n        }\r\n        if ((_base = map.pointers)[ref] == null) {\r\n          _base[ref] = [];\r\n        }\r\n        if (__indexOf.call(map.pointers[ref], keypath) < 0) {\r\n          return map.pointers[ref].push(keypath);\r\n        }\r\n      }\r\n    },\r\n    unobserveMutations: function(obj, ref, keypath) {\r\n      var idx, map, pointers;\r\n      if (Array.isArray(obj) && (obj[this.id] != null)) {\r\n        if (map = this.weakmap[obj[this.id]]) {\r\n          if (pointers = map.pointers[ref]) {\r\n            if ((idx = pointers.indexOf(keypath)) >= 0) {\r\n              pointers.splice(idx, 1);\r\n            }\r\n            if (!pointers.length) {\r\n              delete map.pointers[ref];\r\n            }\r\n            return this.cleanupWeakReference(map, obj[this.id]);\r\n          }\r\n        }\r\n      }\r\n    },\r\n    observe: function(obj, keypath, callback) {\r\n      var callbacks, desc, value;\r\n      callbacks = this.weakReference(obj).callbacks;\r\n      if (callbacks[keypath] == null) {\r\n        callbacks[keypath] = [];\r\n        desc = Object.getOwnPropertyDescriptor(obj, keypath);\r\n        if (!((desc != null ? desc.get : void 0) || (desc != null ? desc.set : void 0))) {\r\n          value = obj[keypath];\r\n          Object.defineProperty(obj, keypath, {\r\n            enumerable: true,\r\n            get: function() {\r\n              return value;\r\n            },\r\n            set: (function(_this) {\r\n              return function(newValue) {\r\n                var cb, map, _i, _len, _ref1;\r\n                if (newValue !== value) {\r\n                  _this.unobserveMutations(value, obj[_this.id], keypath);\r\n                  value = newValue;\r\n                  if (map = _this.weakmap[obj[_this.id]]) {\r\n                    callbacks = map.callbacks;\r\n                    if (callbacks[keypath]) {\r\n                      _ref1 = callbacks[keypath].slice();\r\n                      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\r\n                        cb = _ref1[_i];\r\n                        if (__indexOf.call(callbacks[keypath], cb) >= 0) {\r\n                          cb();\r\n                        }\r\n                      }\r\n                    }\r\n                    return _this.observeMutations(newValue, obj[_this.id], keypath);\r\n                  }\r\n                }\r\n              };\r\n            })(this)\r\n          });\r\n        }\r\n      }\r\n      if (__indexOf.call(callbacks[keypath], callback) < 0) {\r\n        callbacks[keypath].push(callback);\r\n      }\r\n      return this.observeMutations(obj[keypath], obj[this.id], keypath);\r\n    },\r\n    unobserve: function(obj, keypath, callback) {\r\n      var callbacks, idx, map;\r\n      if (map = this.weakmap[obj[this.id]]) {\r\n        if (callbacks = map.callbacks[keypath]) {\r\n          if ((idx = callbacks.indexOf(callback)) >= 0) {\r\n            callbacks.splice(idx, 1);\r\n            if (!callbacks.length) {\r\n              delete map.callbacks[keypath];\r\n              this.unobserveMutations(obj[keypath], obj[this.id], keypath);\r\n            }\r\n          }\r\n          return this.cleanupWeakReference(map, obj[this.id]);\r\n        }\r\n      }\r\n    },\r\n    get: function(obj, keypath) {\r\n      return obj[keypath];\r\n    },\r\n    set: function(obj, keypath, value) {\r\n      return obj[keypath] = value;\r\n    }\r\n  };\r\n\r\n  return Rivets[\"public\"].adapters;\r\n\r\n});\r\n\r\n\ndefine('skylark-rivets/util',[\r\n  \"skylark-utils-dom/query\",\r\n  \"./rivets\"\r\n],function($,Rivets) {\r\n    Rivets.Util = {\r\n      bindEvent: function(el, event, handler) {\r\n        return $(el).on(event, handler);\r\n      },\r\n      unbindEvent: function(el, event, handler) {\r\n        return $(el).off(event, handler);\r\n      },\r\n      getInputValue: function(el) {\r\n        var $el;\r\n        $el = $(el);\r\n        if ($el.attr('type') === 'checkbox') {\r\n          return $el.is(':checked');\r\n        } else {\r\n          return $el.val();\r\n        }\r\n      }\r\n    };\r\n\r\n    return Rivets.Util;\r\n});\r\n\n  define('skylark-rivets/views',[\"./rivets\"],function(Rivets){\r\n    Rivets.View = (function() {\r\n      var  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };\r\n    \r\n      function View(els, models, options) {\r\n        var k, option, v, _base, _i, _j, _len, _len1, _ref1, _ref2, _ref3, _ref4, _ref5;\r\n        this.els = els;\r\n        this.models = models;\r\n        if (options == null) {\r\n          options = {};\r\n        }\r\n        this.update = __bind(this.update, this);\r\n        this.publish = __bind(this.publish, this);\r\n        this.sync = __bind(this.sync, this);\r\n        this.unbind = __bind(this.unbind, this);\r\n        this.bind = __bind(this.bind, this);\r\n        this.select = __bind(this.select, this);\r\n        this.traverse = __bind(this.traverse, this);\r\n        this.build = __bind(this.build, this);\r\n        this.buildBinding = __bind(this.buildBinding, this);\r\n        this.bindingRegExp = __bind(this.bindingRegExp, this);\r\n        this.options = __bind(this.options, this);\r\n        if (!(this.els.jquery || this.els instanceof Array)) {\r\n          this.els = [this.els];\r\n        }\r\n        _ref1 = Rivets.extensions;\r\n        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\r\n          option = _ref1[_i];\r\n          this[option] = {};\r\n          if (options[option]) {\r\n            _ref2 = options[option];\r\n            for (k in _ref2) {\r\n              v = _ref2[k];\r\n              this[option][k] = v;\r\n            }\r\n          }\r\n          _ref3 = Rivets[\"public\"][option];\r\n          for (k in _ref3) {\r\n            v = _ref3[k];\r\n            if ((_base = this[option])[k] == null) {\r\n              _base[k] = v;\r\n            }\r\n          }\r\n        }\r\n        _ref4 = Rivets.options;\r\n        for (_j = 0, _len1 = _ref4.length; _j < _len1; _j++) {\r\n          option = _ref4[_j];\r\n          this[option] = (_ref5 = options[option]) != null ? _ref5 : Rivets[\"public\"][option];\r\n        }\r\n        this.build();\r\n      }\r\n\r\n      View.prototype.options = function() {\r\n        var option, options, _i, _len, _ref1;\r\n        options = {};\r\n        _ref1 = Rivets.extensions.concat(Rivets.options);\r\n        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\r\n          option = _ref1[_i];\r\n          options[option] = this[option];\r\n        }\r\n        return options;\r\n      };\r\n\r\n      View.prototype.bindingRegExp = function() {\r\n        return new RegExp(\"^\" + this.prefix + \"-\");\r\n      };\r\n\r\n      View.prototype.buildBinding = function(binding, node, type, declaration) {\r\n        var context, ctx, dependencies, keypath, options, pipe, pipes;\r\n        options = {};\r\n        pipes = (function() {\r\n          var _i, _len, _ref1, _results;\r\n          _ref1 = declaration.match(/((?:'[^']*')*(?:(?:[^\\|']*(?:'[^']*')+[^\\|']*)+|[^\\|]+))|^$/g);\r\n          _results = [];\r\n          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\r\n            pipe = _ref1[_i];\r\n            _results.push(pipe.trim());\r\n          }\r\n          return _results;\r\n        })();\r\n        context = (function() {\r\n          var _i, _len, _ref1, _results;\r\n          _ref1 = pipes.shift().split('<');\r\n          _results = [];\r\n          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\r\n            ctx = _ref1[_i];\r\n            _results.push(ctx.trim());\r\n          }\r\n          return _results;\r\n        })();\r\n        keypath = context.shift();\r\n        options.formatters = pipes;\r\n        if (dependencies = context.shift()) {\r\n          options.dependencies = dependencies.split(/\\s+/);\r\n        }\r\n        return this.bindings.push(new Rivets[binding](this, node, type, keypath, options));\r\n      };\r\n\r\n      View.prototype.build = function() {\r\n        var el, parse, _i, _len, _ref1;\r\n        this.bindings = [];\r\n        parse = (function(_this) {\r\n          return function(node) {\r\n            var block, childNode, delimiters, n, parser, text, token, tokens, _i, _j, _len, _len1, _ref1;\r\n            if (node.nodeType === 3) {\r\n              parser = Rivets.TextTemplateParser;\r\n              if (delimiters = _this.templateDelimiters) {\r\n                if ((tokens = parser.parse(node.data, delimiters)).length) {\r\n                  if (!(tokens.length === 1 && tokens[0].type === parser.types.text)) {\r\n                    for (_i = 0, _len = tokens.length; _i < _len; _i++) {\r\n                      token = tokens[_i];\r\n                      text = document.createTextNode(token.value);\r\n                      node.parentNode.insertBefore(text, node);\r\n                      if (token.type === 1) {\r\n                        _this.buildBinding('TextBinding', text, null, token.value);\r\n                      }\r\n                    }\r\n                    node.parentNode.removeChild(node);\r\n                  }\r\n                }\r\n              }\r\n            } else if (node.nodeType === 1) {\r\n              block = _this.traverse(node);\r\n            }\r\n            if (!block) {\r\n              _ref1 = (function() {\r\n                var _k, _len1, _ref1, _results;\r\n                _ref1 = node.childNodes;\r\n                _results = [];\r\n                for (_k = 0, _len1 = _ref1.length; _k < _len1; _k++) {\r\n                  n = _ref1[_k];\r\n                  _results.push(n);\r\n                }\r\n                return _results;\r\n              })();\r\n              for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {\r\n                childNode = _ref1[_j];\r\n                parse(childNode);\r\n              }\r\n            }\r\n          };\r\n        })(this);\r\n        _ref1 = this.els;\r\n        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\r\n          el = _ref1[_i];\r\n          parse(el);\r\n        }\r\n        this.bindings.sort(function(a, b) {\r\n          var _ref2, _ref3;\r\n          return (((_ref2 = b.binder) != null ? _ref2.priority : void 0) || 0) - (((_ref3 = a.binder) != null ? _ref3.priority : void 0) || 0);\r\n        });\r\n      };\r\n\r\n      View.prototype.traverse = function(node) {\r\n        var attribute, attributes, binder, bindingRegExp, block, identifier, regexp, type, value, _i, _j, _len, _len1, _ref1, _ref2, _ref3;\r\n        bindingRegExp = this.bindingRegExp();\r\n        block = node.nodeName === 'SCRIPT' || node.nodeName === 'STYLE';\r\n        _ref1 = node.attributes;\r\n        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\r\n          attribute = _ref1[_i];\r\n          if (bindingRegExp.test(attribute.name)) {\r\n            type = attribute.name.replace(bindingRegExp, '');\r\n            if (!(binder = this.binders[type])) {\r\n              _ref2 = this.binders;\r\n              for (identifier in _ref2) {\r\n                value = _ref2[identifier];\r\n                if (identifier !== '*' && identifier.indexOf('*') !== -1) {\r\n                  regexp = new RegExp(\"^\" + (identifier.replace(/\\*/g, '.+')) + \"$\");\r\n                  if (regexp.test(type)) {\r\n                    binder = value;\r\n                  }\r\n                }\r\n              }\r\n            }\r\n            binder || (binder = this.binders['*']);\r\n            if (binder.block) {\r\n              block = true;\r\n              attributes = [attribute];\r\n            }\r\n          }\r\n        }\r\n        _ref3 = attributes || node.attributes;\r\n        for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {\r\n          attribute = _ref3[_j];\r\n          if (bindingRegExp.test(attribute.name)) {\r\n            type = attribute.name.replace(bindingRegExp, '');\r\n            this.buildBinding('Binding', node, type, attribute.value);\r\n          }\r\n        }\r\n        if (!block) {\r\n          type = node.nodeName.toLowerCase();\r\n          if (this.components[type] && !node._bound) {\r\n            this.bindings.push(new Rivets.ComponentBinding(this, node, type));\r\n            block = true;\r\n          }\r\n        }\r\n        return block;\r\n      };\r\n\r\n      View.prototype.select = function(fn) {\r\n        var binding, _i, _len, _ref1, _results;\r\n        _ref1 = this.bindings;\r\n        _results = [];\r\n        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\r\n          binding = _ref1[_i];\r\n          if (fn(binding)) {\r\n            _results.push(binding);\r\n          }\r\n        }\r\n        return _results;\r\n      };\r\n\r\n      View.prototype.bind = function() {\r\n        var binding, _i, _len, _ref1;\r\n        _ref1 = this.bindings;\r\n        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\r\n          binding = _ref1[_i];\r\n          binding.bind();\r\n        }\r\n      };\r\n\r\n      View.prototype.unbind = function() {\r\n        var binding, _i, _len, _ref1;\r\n        _ref1 = this.bindings;\r\n        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\r\n          binding = _ref1[_i];\r\n          binding.unbind();\r\n        }\r\n      };\r\n\r\n      View.prototype.sync = function() {\r\n        var binding, _i, _len, _ref1;\r\n        _ref1 = this.bindings;\r\n        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\r\n          binding = _ref1[_i];\r\n          if (typeof binding.sync === \"function\") {\r\n            binding.sync();\r\n          }\r\n        }\r\n      };\r\n\r\n      View.prototype.publish = function() {\r\n        var binding, _i, _len, _ref1;\r\n        _ref1 = this.select(function(b) {\r\n          var _ref1;\r\n          return (_ref1 = b.binder) != null ? _ref1.publishes : void 0;\r\n        });\r\n        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\r\n          binding = _ref1[_i];\r\n          binding.publish();\r\n        }\r\n      };\r\n\r\n      View.prototype.update = function(models) {\r\n        var binding, key, model, _i, _len, _ref1;\r\n        if (models == null) {\r\n          models = {};\r\n        }\r\n        for (key in models) {\r\n          model = models[key];\r\n          this.models[key] = model;\r\n        }\r\n        _ref1 = this.bindings;\r\n        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\r\n          binding = _ref1[_i];\r\n          if (typeof binding.update === \"function\") {\r\n            binding.update(models);\r\n          }\r\n        }\r\n      };\r\n\r\n      return View;\r\n\r\n    })();\r\n\r\n    return {\r\n      View : Rivets.View\r\n    };\r\n  });\r\n\r\n\ndefine('skylark-rivets/binders',[\r\n  \"./rivets\",\r\n  \"./util\",\r\n  \"./views\"\r\n],function(Rivets){\r\n  var __indexOf = [].indexOf;\r\n\r\n  Rivets[\"public\"].binders.text = function(el, value) {\r\n    if (el.textContent != null) {\r\n      return el.textContent = value != null ? value : '';\r\n    } else {\r\n      return el.innerText = value != null ? value : '';\r\n    }\r\n  };\r\n\r\n  Rivets[\"public\"].binders.html = function(el, value) {\r\n    return el.innerHTML = value != null ? value : '';\r\n  };\r\n\r\n  Rivets[\"public\"].binders.show = function(el, value) {\r\n    return el.style.display = value ? '' : 'none';\r\n  };\r\n\r\n  Rivets[\"public\"].binders.hide = function(el, value) {\r\n    return el.style.display = value ? 'none' : '';\r\n  };\r\n\r\n  Rivets[\"public\"].binders.enabled = function(el, value) {\r\n    return el.disabled = !value;\r\n  };\r\n\r\n  Rivets[\"public\"].binders.disabled = function(el, value) {\r\n    return el.disabled = !!value;\r\n  };\r\n\r\n  Rivets[\"public\"].binders.checked = {\r\n    publishes: true,\r\n    priority: 2000,\r\n    bind: function(el) {\r\n      return Rivets.Util.bindEvent(el, 'change', this.publish);\r\n    },\r\n    unbind: function(el) {\r\n      return Rivets.Util.unbindEvent(el, 'change', this.publish);\r\n    },\r\n    routine: function(el, value) {\r\n      var _ref1;\r\n      if (el.type === 'radio') {\r\n        return el.checked = ((_ref1 = el.value) != null ? _ref1.toString() : void 0) === (value != null ? value.toString() : void 0);\r\n      } else {\r\n        return el.checked = !!value;\r\n      }\r\n    }\r\n  };\r\n\r\n  Rivets[\"public\"].binders.unchecked = {\r\n    publishes: true,\r\n    priority: 2000,\r\n    bind: function(el) {\r\n      return Rivets.Util.bindEvent(el, 'change', this.publish);\r\n    },\r\n    unbind: function(el) {\r\n      return Rivets.Util.unbindEvent(el, 'change', this.publish);\r\n    },\r\n    routine: function(el, value) {\r\n      var _ref1;\r\n      if (el.type === 'radio') {\r\n        return el.checked = ((_ref1 = el.value) != null ? _ref1.toString() : void 0) !== (value != null ? value.toString() : void 0);\r\n      } else {\r\n        return el.checked = !value;\r\n      }\r\n    }\r\n  };\r\n\r\n  Rivets[\"public\"].binders.value = {\r\n    publishes: true,\r\n    priority: 3000,\r\n    bind: function(el) {\r\n      if (!(el.tagName === 'INPUT' && el.type === 'radio')) {\r\n        this.event = el.tagName === 'SELECT' ? 'change' : 'input';\r\n        return Rivets.Util.bindEvent(el, this.event, this.publish);\r\n      }\r\n    },\r\n    unbind: function(el) {\r\n      if (!(el.tagName === 'INPUT' && el.type === 'radio')) {\r\n        return Rivets.Util.unbindEvent(el, this.event, this.publish);\r\n      }\r\n    },\r\n    routine: function(el, value) {\r\n      var o, _i, _len, _ref1, _ref2, _ref3, _results;\r\n      if (el.tagName === 'INPUT' && el.type === 'radio') {\r\n        return el.setAttribute('value', value);\r\n      } else if (window.jQuery != null) {\r\n        el = jQuery(el);\r\n        if ((value != null ? value.toString() : void 0) !== ((_ref1 = el.val()) != null ? _ref1.toString() : void 0)) {\r\n          return el.val(value != null ? value : '');\r\n        }\r\n      } else {\r\n        if (el.type === 'select-multiple') {\r\n          if (value != null) {\r\n            _results = [];\r\n            for (_i = 0, _len = el.length; _i < _len; _i++) {\r\n              o = el[_i];\r\n              _results.push(o.selected = (_ref2 = o.value, __indexOf.call(value, _ref2) >= 0));\r\n            }\r\n            return _results;\r\n          }\r\n        } else if ((value != null ? value.toString() : void 0) !== ((_ref3 = el.value) != null ? _ref3.toString() : void 0)) {\r\n          return el.value = value != null ? value : '';\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  Rivets[\"public\"].binders[\"if\"] = {\r\n    block: true,\r\n    priority: 4000,\r\n    bind: function(el) {\r\n      var attr, declaration;\r\n      if (this.marker == null) {\r\n        attr = [this.view.prefix, this.type].join('-').replace('--', '-');\r\n        declaration = el.getAttribute(attr);\r\n        this.marker = document.createComment(\" rivets: \" + this.type + \" \" + declaration + \" \");\r\n        this.bound = false;\r\n        el.removeAttribute(attr);\r\n        el.parentNode.insertBefore(this.marker, el);\r\n        return el.parentNode.removeChild(el);\r\n      }\r\n    },\r\n    unbind: function() {\r\n      if (this.nested) {\r\n        this.nested.unbind();\r\n        return this.bound = false;\r\n      }\r\n    },\r\n    routine: function(el, value) {\r\n      var key, model, models, _ref1;\r\n      if (!!value === !this.bound) {\r\n        if (value) {\r\n          models = {};\r\n          _ref1 = this.view.models;\r\n          for (key in _ref1) {\r\n            model = _ref1[key];\r\n            models[key] = model;\r\n          }\r\n          (this.nested || (this.nested = new Rivets.View(el, models, this.view.options()))).bind();\r\n          this.marker.parentNode.insertBefore(el, this.marker.nextSibling);\r\n          return this.bound = true;\r\n        } else {\r\n          el.parentNode.removeChild(el);\r\n          this.nested.unbind();\r\n          return this.bound = false;\r\n        }\r\n      }\r\n    },\r\n    update: function(models) {\r\n      var _ref1;\r\n      return (_ref1 = this.nested) != null ? _ref1.update(models) : void 0;\r\n    }\r\n  };\r\n\r\n  Rivets[\"public\"].binders.unless = {\r\n    block: true,\r\n    priority: 4000,\r\n    bind: function(el) {\r\n      return Rivets[\"public\"].binders[\"if\"].bind.call(this, el);\r\n    },\r\n    unbind: function() {\r\n      return Rivets[\"public\"].binders[\"if\"].unbind.call(this);\r\n    },\r\n    routine: function(el, value) {\r\n      return Rivets[\"public\"].binders[\"if\"].routine.call(this, el, !value);\r\n    },\r\n    update: function(models) {\r\n      return Rivets[\"public\"].binders[\"if\"].update.call(this, models);\r\n    }\r\n  };\r\n\r\n  Rivets[\"public\"].binders['on-*'] = {\r\n    \"function\": true,\r\n    priority: 1000,\r\n    unbind: function(el) {\r\n      if (this.handler) {\r\n        return Rivets.Util.unbindEvent(el, this.args[0], this.handler);\r\n      }\r\n    },\r\n    routine: function(el, value) {\r\n      if (this.handler) {\r\n        Rivets.Util.unbindEvent(el, this.args[0], this.handler);\r\n      }\r\n      return Rivets.Util.bindEvent(el, this.args[0], this.handler = this.eventHandler(value));\r\n    }\r\n  };\r\n\r\n  Rivets[\"public\"].binders['each-*'] = {\r\n    block: true,\r\n    priority: 4000,\r\n    bind: function(el) {\r\n      var attr, view, _i, _len, _ref1;\r\n      if (this.marker == null) {\r\n        attr = [this.view.prefix, this.type].join('-').replace('--', '-');\r\n        this.marker = document.createComment(\" rivets: \" + this.type + \" \");\r\n        this.iterated = [];\r\n        el.removeAttribute(attr);\r\n        el.parentNode.insertBefore(this.marker, el);\r\n        el.parentNode.removeChild(el);\r\n      } else {\r\n        _ref1 = this.iterated;\r\n        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\r\n          view = _ref1[_i];\r\n          view.bind();\r\n        }\r\n      }\r\n    },\r\n    unbind: function(el) {\r\n      var view, _i, _len, _ref1;\r\n      if (this.iterated != null) {\r\n        _ref1 = this.iterated;\r\n        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\r\n          view = _ref1[_i];\r\n          view.unbind();\r\n        }\r\n      }\r\n    },\r\n    routine: function(el, collection) {\r\n      var binding, data, i, index, key, model, modelName, options, previous, template, view, _i, _j, _k, _len, _len1, _len2, _ref1, _ref2, _ref3;\r\n      modelName = this.args[0];\r\n      collection = collection || [];\r\n      if (this.iterated.length > collection.length) {\r\n        _ref1 = Array(this.iterated.length - collection.length);\r\n        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\r\n          i = _ref1[_i];\r\n          view = this.iterated.pop();\r\n          view.unbind();\r\n          this.marker.parentNode.removeChild(view.els[0]);\r\n        }\r\n      }\r\n      for (index = _j = 0, _len1 = collection.length; _j < _len1; index = ++_j) {\r\n        model = collection[index];\r\n        data = {\r\n          index: index\r\n        };\r\n        data[Rivets[\"public\"].iterationAlias(modelName)] = index;\r\n        data[modelName] = model;\r\n        if (this.iterated[index] == null) {\r\n          _ref2 = this.view.models;\r\n          for (key in _ref2) {\r\n            model = _ref2[key];\r\n            if (data[key] == null) {\r\n              data[key] = model;\r\n            }\r\n          }\r\n          previous = this.iterated.length ? this.iterated[this.iterated.length - 1].els[0] : this.marker;\r\n          options = this.view.options();\r\n          options.preloadData = true;\r\n          template = el.cloneNode(true);\r\n          view = new Rivets.View(template, data, options);\r\n          view.bind();\r\n          this.iterated.push(view);\r\n          this.marker.parentNode.insertBefore(template, previous.nextSibling);\r\n        } else if (this.iterated[index].models[modelName] !== model) {\r\n          this.iterated[index].update(data);\r\n        }\r\n      }\r\n      if (el.nodeName === 'OPTION') {\r\n        _ref3 = this.view.bindings;\r\n        for (_k = 0, _len2 = _ref3.length; _k < _len2; _k++) {\r\n          binding = _ref3[_k];\r\n          if (binding.el === this.marker.parentNode && binding.type === 'value') {\r\n            binding.sync();\r\n          }\r\n        }\r\n      }\r\n    },\r\n    update: function(models) {\r\n      var data, key, model, view, _i, _len, _ref1;\r\n      data = {};\r\n      for (key in models) {\r\n        model = models[key];\r\n        if (key !== this.args[0]) {\r\n          data[key] = model;\r\n        }\r\n      }\r\n      _ref1 = this.iterated;\r\n      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\r\n        view = _ref1[_i];\r\n        view.update(data);\r\n      }\r\n    }\r\n  };\r\n\r\n  Rivets[\"public\"].binders['class-*'] = function(el, value) {\r\n    var elClass;\r\n    elClass = \" \" + el.className + \" \";\r\n    if (!value === (elClass.indexOf(\" \" + this.args[0] + \" \") !== -1)) {\r\n      return el.className = value ? \"\" + el.className + \" \" + this.args[0] : elClass.replace(\" \" + this.args[0] + \" \", ' ').trim();\r\n    }\r\n  };\r\n\r\n  Rivets[\"public\"].binders['*'] = function(el, value) {\r\n    if (value != null) {\r\n      return el.setAttribute(this.type, value);\r\n    } else {\r\n      return el.removeAttribute(this.type);\r\n    }\r\n  };\r\n\r\n  return Rivets[\"public\"].binders;\r\n\r\n});\r\n\r\n\ndefine('skylark-rivets/parsers',[\"./rivets\"],function(Rivets){\r\n\r\n  Rivets.TypeParser = (function() {\r\n    function TypeParser() {}\r\n\r\n    TypeParser.types = {\r\n      primitive: 0,\r\n      keypath: 1\r\n    };\r\n\r\n    TypeParser.parse = function(string) {\r\n      if (/^'.*'$|^\".*\"$/.test(string)) {\r\n        return {\r\n          type: this.types.primitive,\r\n          value: string.slice(1, -1)\r\n        };\r\n      } else if (string === 'true') {\r\n        return {\r\n          type: this.types.primitive,\r\n          value: true\r\n        };\r\n      } else if (string === 'false') {\r\n        return {\r\n          type: this.types.primitive,\r\n          value: false\r\n        };\r\n      } else if (string === 'null') {\r\n        return {\r\n          type: this.types.primitive,\r\n          value: null\r\n        };\r\n      } else if (string === 'undefined') {\r\n        return {\r\n          type: this.types.primitive,\r\n          value: void 0\r\n        };\r\n      } else if (string === '') {\r\n        return {\r\n          type: this.types.primitive,\r\n          value: void 0\r\n        };\r\n      } else if (isNaN(Number(string)) === false) {\r\n        return {\r\n          type: this.types.primitive,\r\n          value: Number(string)\r\n        };\r\n      } else {\r\n        return {\r\n          type: this.types.keypath,\r\n          value: string\r\n        };\r\n      }\r\n    };\r\n\r\n    return TypeParser;\r\n\r\n  })();\r\n\r\n  Rivets.TextTemplateParser = (function() {\r\n    function TextTemplateParser() {}\r\n\r\n    TextTemplateParser.types = {\r\n      text: 0,\r\n      binding: 1\r\n    };\r\n\r\n    TextTemplateParser.parse = function(template, delimiters) {\r\n      var index, lastIndex, lastToken, length, substring, tokens, value;\r\n      tokens = [];\r\n      length = template.length;\r\n      index = 0;\r\n      lastIndex = 0;\r\n      while (lastIndex < length) {\r\n        index = template.indexOf(delimiters[0], lastIndex);\r\n        if (index < 0) {\r\n          tokens.push({\r\n            type: this.types.text,\r\n            value: template.slice(lastIndex)\r\n          });\r\n          break;\r\n        } else {\r\n          if (index > 0 && lastIndex < index) {\r\n            tokens.push({\r\n              type: this.types.text,\r\n              value: template.slice(lastIndex, index)\r\n            });\r\n          }\r\n          lastIndex = index + delimiters[0].length;\r\n          index = template.indexOf(delimiters[1], lastIndex);\r\n          if (index < 0) {\r\n            substring = template.slice(lastIndex - delimiters[1].length);\r\n            lastToken = tokens[tokens.length - 1];\r\n            if ((lastToken != null ? lastToken.type : void 0) === this.types.text) {\r\n              lastToken.value += substring;\r\n            } else {\r\n              tokens.push({\r\n                type: this.types.text,\r\n                value: substring\r\n              });\r\n            }\r\n            break;\r\n          }\r\n          value = template.slice(lastIndex, index).trim();\r\n          tokens.push({\r\n            type: this.types.binding,\r\n            value: value\r\n          });\r\n          lastIndex = index + delimiters[1].length;\r\n        }\r\n      }\r\n      return tokens;\r\n    };\r\n\r\n    return TextTemplateParser;\r\n\r\n  })();\r\n\r\n\r\n  return {\r\n    TypeParser : Rivets.TypeParser,\r\n    TextTemplateParser : Rivets.TextTemplateParser\r\n  };\r\n\r\n});\r\n\r\n\ndefine('skylark-rivets/bindings',[\r\n  \"./rivets\",\r\n  \"./sightglass\",\r\n  \"./util\",\r\n  \"./parsers\",\r\n  \"./views\"\r\n],function(Rivets){\r\n\r\n  var __extends = function(child, parent) { \r\n    for (var key in parent) { \r\n      if (__hasProp.call(parent, key)) \r\n        child[key] = parent[key]; \r\n    } \r\n    function ctor() { \r\n      this.constructor = child; \r\n    } \r\n    ctor.prototype = parent.prototype; \r\n    child.prototype = new ctor(); \r\n    child.__super__ = parent.prototype; \r\n    return child; \r\n  },__hasProp = {}.hasOwnProperty,\r\n    __slice = [].slice,\r\n    __indexOf = [].indexOf,\r\n    __bind = function(fn, me){ \r\n      return function(){ \r\n        return fn.apply(me, arguments); }; \r\n    };\r\n\r\n\r\n  Rivets.Binding = (function() {\r\n    function Binding(view, el, type, keypath, options) {\r\n      this.view = view;\r\n      this.el = el;\r\n      this.type = type;\r\n      this.keypath = keypath;\r\n      this.options = options != null ? options : {};\r\n      this.getValue = __bind(this.getValue, this);\r\n      this.update = __bind(this.update, this);\r\n      this.unbind = __bind(this.unbind, this);\r\n      this.bind = __bind(this.bind, this);\r\n      this.publish = __bind(this.publish, this);\r\n      this.sync = __bind(this.sync, this);\r\n      this.set = __bind(this.set, this);\r\n      this.eventHandler = __bind(this.eventHandler, this);\r\n      this.formattedValue = __bind(this.formattedValue, this);\r\n      this.parseFormatterArguments = __bind(this.parseFormatterArguments, this);\r\n      this.parseTarget = __bind(this.parseTarget, this);\r\n      this.observe = __bind(this.observe, this);\r\n      this.setBinder = __bind(this.setBinder, this);\r\n      this.formatters = this.options.formatters || [];\r\n      this.dependencies = [];\r\n      this.formatterObservers = {};\r\n      this.model = void 0;\r\n      this.setBinder();\r\n    }\r\n\r\n    Binding.prototype.setBinder = function() {\r\n      var identifier, regexp, value, _ref1;\r\n      if (!(this.binder = this.view.binders[this.type])) {\r\n        _ref1 = this.view.binders;\r\n        for (identifier in _ref1) {\r\n          value = _ref1[identifier];\r\n          if (identifier !== '*' && identifier.indexOf('*') !== -1) {\r\n            regexp = new RegExp(\"^\" + (identifier.replace(/\\*/g, '.+')) + \"$\");\r\n            if (regexp.test(this.type)) {\r\n              this.binder = value;\r\n              this.args = new RegExp(\"^\" + (identifier.replace(/\\*/g, '(.+)')) + \"$\").exec(this.type);\r\n              this.args.shift();\r\n            }\r\n          }\r\n        }\r\n      }\r\n      this.binder || (this.binder = this.view.binders['*']);\r\n      if (this.binder instanceof Function) {\r\n        return this.binder = {\r\n          routine: this.binder\r\n        };\r\n      }\r\n    };\r\n\r\n    Binding.prototype.observe = function(obj, keypath, callback) {\r\n      return Rivets.sightglass(obj, keypath, callback, {\r\n        root: this.view.rootInterface,\r\n        adapters: this.view.adapters\r\n      });\r\n    };\r\n\r\n    Binding.prototype.parseTarget = function() {\r\n      var token;\r\n      token = Rivets.TypeParser.parse(this.keypath);\r\n      if (token.type === Rivets.TypeParser.types.primitive) {\r\n        return this.value = token.value;\r\n      } else {\r\n        this.observer = this.observe(this.view.models, this.keypath, this.sync);\r\n        return this.model = this.observer.target;\r\n      }\r\n    };\r\n\r\n    Binding.prototype.parseFormatterArguments = function(args, formatterIndex) {\r\n      var ai, arg, observer, processedArgs, _base, _i, _len;\r\n      args = (function() {\r\n        var _i, _len, _results;\r\n        _results = [];\r\n        for (_i = 0, _len = args.length; _i < _len; _i++) {\r\n          arg = args[_i];\r\n          _results.push(Rivets.TypeParser.parse(arg));\r\n        }\r\n        return _results;\r\n      })();\r\n      processedArgs = [];\r\n      for (ai = _i = 0, _len = args.length; _i < _len; ai = ++_i) {\r\n        arg = args[ai];\r\n        processedArgs.push(arg.type === Rivets.TypeParser.types.primitive ? arg.value : ((_base = this.formatterObservers)[formatterIndex] || (_base[formatterIndex] = {}), !(observer = this.formatterObservers[formatterIndex][ai]) ? (observer = this.observe(this.view.models, arg.value, this.sync), this.formatterObservers[formatterIndex][ai] = observer) : void 0, observer.value()));\r\n      }\r\n      return processedArgs;\r\n    };\r\n\r\n    Binding.prototype.formattedValue = function(value) {\r\n      var args, fi, formatter, id, processedArgs, _i, _len, _ref1, _ref2;\r\n      _ref1 = this.formatters;\r\n      for (fi = _i = 0, _len = _ref1.length; _i < _len; fi = ++_i) {\r\n        formatter = _ref1[fi];\r\n        args = formatter.match(/[^\\s']+|'([^']|'[^\\s])*'|\"([^\"]|\"[^\\s])*\"/g);\r\n        id = args.shift();\r\n        formatter = this.view.formatters[id];\r\n        processedArgs = this.parseFormatterArguments(args, fi);\r\n        if ((formatter != null ? formatter.read : void 0) instanceof Function) {\r\n          value = (_ref2 = formatter.read).call.apply(_ref2, [this.model, value].concat(__slice.call(processedArgs)));\r\n        } else if (formatter instanceof Function) {\r\n          value = formatter.call.apply(formatter, [this.model, value].concat(__slice.call(processedArgs)));\r\n        }\r\n      }\r\n      return value;\r\n    };\r\n\r\n    Binding.prototype.eventHandler = function(fn) {\r\n      var binding, handler;\r\n      handler = (binding = this).view.handler;\r\n      return function(ev) {\r\n        return handler.call(fn, this, ev, binding);\r\n      };\r\n    };\r\n\r\n    Binding.prototype.set = function(value) {\r\n      var _ref1;\r\n      value = value instanceof Function && !this.binder[\"function\"] && Rivets[\"public\"].executeFunctions ? this.formattedValue(value.call(this.model)) : this.formattedValue(value);\r\n      return (_ref1 = this.binder.routine) != null ? _ref1.call(this, this.el, value) : void 0;\r\n    };\r\n\r\n    Binding.prototype.sync = function() {\r\n      var dependency, observer;\r\n      return this.set((function() {\r\n        var _i, _j, _len, _len1, _ref1, _ref2, _ref3;\r\n        if (this.observer) {\r\n          if (this.model !== this.observer.target) {\r\n            _ref1 = this.dependencies;\r\n            for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\r\n              observer = _ref1[_i];\r\n              observer.unobserve();\r\n            }\r\n            this.dependencies = [];\r\n            if (((this.model = this.observer.target) != null) && ((_ref2 = this.options.dependencies) != null ? _ref2.length : void 0)) {\r\n              _ref3 = this.options.dependencies;\r\n              for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {\r\n                dependency = _ref3[_j];\r\n                observer = this.observe(this.model, dependency, this.sync);\r\n                this.dependencies.push(observer);\r\n              }\r\n            }\r\n          }\r\n          return this.observer.value();\r\n        } else {\r\n          return this.value;\r\n        }\r\n      }).call(this));\r\n    };\r\n\r\n    Binding.prototype.publish = function() {\r\n      var args, fi, fiReversed, formatter, id, lastformatterIndex, processedArgs, value, _i, _len, _ref1, _ref2, _ref3;\r\n      if (this.observer) {\r\n        value = this.getValue(this.el);\r\n        lastformatterIndex = this.formatters.length - 1;\r\n        _ref1 = this.formatters.slice(0).reverse();\r\n        for (fiReversed = _i = 0, _len = _ref1.length; _i < _len; fiReversed = ++_i) {\r\n          formatter = _ref1[fiReversed];\r\n          fi = lastformatterIndex - fiReversed;\r\n          args = formatter.split(/\\s+/);\r\n          id = args.shift();\r\n          processedArgs = this.parseFormatterArguments(args, fi);\r\n          if ((_ref2 = this.view.formatters[id]) != null ? _ref2.publish : void 0) {\r\n            value = (_ref3 = this.view.formatters[id]).publish.apply(_ref3, [value].concat(__slice.call(processedArgs)));\r\n          }\r\n        }\r\n        return this.observer.setValue(value);\r\n      }\r\n    };\r\n\r\n    Binding.prototype.bind = function() {\r\n      var dependency, observer, _i, _len, _ref1, _ref2, _ref3;\r\n      this.parseTarget();\r\n      if ((_ref1 = this.binder.bind) != null) {\r\n        _ref1.call(this, this.el);\r\n      }\r\n      if ((this.model != null) && ((_ref2 = this.options.dependencies) != null ? _ref2.length : void 0)) {\r\n        _ref3 = this.options.dependencies;\r\n        for (_i = 0, _len = _ref3.length; _i < _len; _i++) {\r\n          dependency = _ref3[_i];\r\n          observer = this.observe(this.model, dependency, this.sync);\r\n          this.dependencies.push(observer);\r\n        }\r\n      }\r\n      if (this.view.preloadData) {\r\n        return this.sync();\r\n      }\r\n    };\r\n\r\n    Binding.prototype.unbind = function() {\r\n      var ai, args, fi, observer, _i, _len, _ref1, _ref2, _ref3, _ref4;\r\n      if ((_ref1 = this.binder.unbind) != null) {\r\n        _ref1.call(this, this.el);\r\n      }\r\n      if ((_ref2 = this.observer) != null) {\r\n        _ref2.unobserve();\r\n      }\r\n      _ref3 = this.dependencies;\r\n      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {\r\n        observer = _ref3[_i];\r\n        observer.unobserve();\r\n      }\r\n      this.dependencies = [];\r\n      _ref4 = this.formatterObservers;\r\n      for (fi in _ref4) {\r\n        args = _ref4[fi];\r\n        for (ai in args) {\r\n          observer = args[ai];\r\n          observer.unobserve();\r\n        }\r\n      }\r\n      return this.formatterObservers = {};\r\n    };\r\n\r\n    Binding.prototype.update = function(models) {\r\n      var _ref1, _ref2;\r\n      if (models == null) {\r\n        models = {};\r\n      }\r\n      this.model = (_ref1 = this.observer) != null ? _ref1.target : void 0;\r\n      return (_ref2 = this.binder.update) != null ? _ref2.call(this, models) : void 0;\r\n    };\r\n\r\n    Binding.prototype.getValue = function(el) {\r\n      if (this.binder && (this.binder.getValue != null)) {\r\n        return this.binder.getValue.call(this, el);\r\n      } else {\r\n        return Rivets.Util.getInputValue(el);\r\n      }\r\n    };\r\n\r\n    return Binding;\r\n\r\n  })();\r\n\r\n  Rivets.ComponentBinding = (function(_super) {\r\n    __extends(ComponentBinding, _super);\r\n\r\n    function ComponentBinding(view, el, type) {\r\n      var attribute, bindingRegExp, propertyName, token, _i, _len, _ref1, _ref2;\r\n      this.view = view;\r\n      this.el = el;\r\n      this.type = type;\r\n      this.unbind = __bind(this.unbind, this);\r\n      this.bind = __bind(this.bind, this);\r\n      this.locals = __bind(this.locals, this);\r\n      this.component = this.view.components[this.type];\r\n      this[\"static\"] = {};\r\n      this.observers = {};\r\n      this.upstreamObservers = {};\r\n      bindingRegExp = view.bindingRegExp();\r\n      _ref1 = this.el.attributes || [];\r\n      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\r\n        attribute = _ref1[_i];\r\n        if (!bindingRegExp.test(attribute.name)) {\r\n          propertyName = this.camelCase(attribute.name);\r\n          token = Rivets.TypeParser.parse(attribute.value);\r\n          if (__indexOf.call((_ref2 = this.component[\"static\"]) != null ? _ref2 : [], propertyName) >= 0) {\r\n            this[\"static\"][propertyName] = attribute.value;\r\n          } else if (token.type === Rivets.TypeParser.types.primitive) {\r\n            this[\"static\"][propertyName] = token.value;\r\n          } else {\r\n            this.observers[propertyName] = attribute.value;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    ComponentBinding.prototype.sync = function() {};\r\n\r\n    ComponentBinding.prototype.update = function() {};\r\n\r\n    ComponentBinding.prototype.publish = function() {};\r\n\r\n    ComponentBinding.prototype.locals = function() {\r\n      var key, observer, result, value, _ref1, _ref2;\r\n      result = {};\r\n      _ref1 = this[\"static\"];\r\n      for (key in _ref1) {\r\n        value = _ref1[key];\r\n        result[key] = value;\r\n      }\r\n      _ref2 = this.observers;\r\n      for (key in _ref2) {\r\n        observer = _ref2[key];\r\n        result[key] = observer.value();\r\n      }\r\n      return result;\r\n    };\r\n\r\n    ComponentBinding.prototype.camelCase = function(string) {\r\n      return string.replace(/-([a-z])/g, function(grouped) {\r\n        return grouped[1].toUpperCase();\r\n      });\r\n    };\r\n\r\n    ComponentBinding.prototype.bind = function() {\r\n      var k, key, keypath, observer, option, options, scope, v, _base, _i, _j, _len, _len1, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7;\r\n      if (!this.bound) {\r\n        _ref1 = this.observers;\r\n        for (key in _ref1) {\r\n          keypath = _ref1[key];\r\n          this.observers[key] = this.observe(this.view.models, keypath, ((function(_this) {\r\n            return function(key) {\r\n              return function() {\r\n                return _this.componentView.models[key] = _this.observers[key].value();\r\n              };\r\n            };\r\n          })(this)).call(this, key));\r\n        }\r\n        this.bound = true;\r\n      }\r\n      if (this.componentView != null) {\r\n        this.componentView.bind();\r\n      } else {\r\n        this.el.innerHTML = this.component.template.call(this);\r\n        scope = this.component.initialize.call(this, this.el, this.locals());\r\n        this.el._bound = true;\r\n        options = {};\r\n        _ref2 = Rivets.extensions;\r\n        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {\r\n          option = _ref2[_i];\r\n          options[option] = {};\r\n          if (this.component[option]) {\r\n            _ref3 = this.component[option];\r\n            for (k in _ref3) {\r\n              v = _ref3[k];\r\n              options[option][k] = v;\r\n            }\r\n          }\r\n          _ref4 = this.view[option];\r\n          for (k in _ref4) {\r\n            v = _ref4[k];\r\n            if ((_base = options[option])[k] == null) {\r\n              _base[k] = v;\r\n            }\r\n          }\r\n        }\r\n        _ref5 = Rivets.options;\r\n        for (_j = 0, _len1 = _ref5.length; _j < _len1; _j++) {\r\n          option = _ref5[_j];\r\n          options[option] = (_ref6 = this.component[option]) != null ? _ref6 : this.view[option];\r\n        }\r\n        this.componentView = new Rivets.View(Array.prototype.slice.call(this.el.childNodes), scope, options);\r\n        this.componentView.bind();\r\n        _ref7 = this.observers;\r\n        for (key in _ref7) {\r\n          observer = _ref7[key];\r\n          this.upstreamObservers[key] = this.observe(this.componentView.models, key, ((function(_this) {\r\n            return function(key, observer) {\r\n              return function() {\r\n                return observer.setValue(_this.componentView.models[key]);\r\n              };\r\n            };\r\n          })(this)).call(this, key, observer));\r\n        }\r\n      }\r\n    };\r\n\r\n    ComponentBinding.prototype.unbind = function() {\r\n      var key, observer, _ref1, _ref2, _ref3;\r\n      _ref1 = this.upstreamObservers;\r\n      for (key in _ref1) {\r\n        observer = _ref1[key];\r\n        observer.unobserve();\r\n      }\r\n      _ref2 = this.observers;\r\n      for (key in _ref2) {\r\n        observer = _ref2[key];\r\n        observer.unobserve();\r\n      }\r\n      return (_ref3 = this.componentView) != null ? _ref3.unbind.call(this) : void 0;\r\n    };\r\n\r\n    return ComponentBinding;\r\n\r\n  })(Rivets.Binding);\r\n\r\n  Rivets.TextBinding = (function(_super) {\r\n    __extends(TextBinding, _super);\r\n\r\n    function TextBinding(view, el, type, keypath, options) {\r\n      this.view = view;\r\n      this.el = el;\r\n      this.type = type;\r\n      this.keypath = keypath;\r\n      this.options = options != null ? options : {};\r\n      this.sync = __bind(this.sync, this);\r\n      this.formatters = this.options.formatters || [];\r\n      this.dependencies = [];\r\n      this.formatterObservers = {};\r\n    }\r\n\r\n    TextBinding.prototype.binder = {\r\n      routine: function(node, value) {\r\n        return node.data = value != null ? value : '';\r\n      }\r\n    };\r\n\r\n    TextBinding.prototype.sync = function() {\r\n      return TextBinding.__super__.sync.apply(this, arguments);\r\n    };\r\n\r\n    return TextBinding;\r\n\r\n  })(Rivets.Binding);\r\n\r\n  return {\r\n    Binding : Rivets.Binding,\r\n    ComponentBinding: Rivets.ComponentBinding,\r\n    TextBinding: Rivets.TextBinding\r\n  };\r\n});\r\n\ndefine('skylark-rivets/formatters',[\"./rivets\"],function(Rivets){\r\n  var  __slice = [].slice;\r\n\r\n  Rivets[\"public\"].formatters['call'] = function() {\r\n    var args, value;\r\n    value = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];\r\n    return value.call.apply(value, [this].concat(__slice.call(args)));\r\n  };\r\n\r\n  return Rivets[\"public\"].formatters;\r\n\r\n});\r\n\ndefine('skylark-rivets/factory',[\r\n\t\"./rivets\",\r\n\t\"./adapter\",\r\n\t\"./binders\",\r\n\t\"./bindings\",\r\n\t\"./formatters\",\r\n\t\"./parsers\",\r\n\t\"./util\",\r\n\t\"./views\"\r\n],function(Rivets){\r\n\tRivets.factory = function(sightglass) {\r\n\t    Rivets.sightglass = sightglass;\r\n\t    Rivets[\"public\"]._ = Rivets;\r\n\t    return Rivets[\"public\"];\r\n\t};\r\n\r\n\treturn Rivets.factory;\r\n});\ndefine('skylark-rivets/main',[\r\n\t\"./sightglass\",\r\n\t\"./factory\"\r\n],function(sightglass,factory){\r\n    return new factory(sightglass);\r\n});\ndefine('skylark-rivets', ['skylark-rivets/main'], function (main) { return main; });\n\n"]}